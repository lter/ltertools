# Load needed libraries
librarian::shelf(tidyverse, supportR, microbenchmark, parallel)

# Clear enviro.
rm(list = ls()); gc()

## ----------------------------- ##
# Define / Test V2 ----
## ----------------------------- ##

# Define new function
harm_v2 <- function(key = NULL, raw_folder = NULL, data_format = c("csv", "txt", "xls", "xlsx"), quiet = TRUE){
  # Squelch 'visible bindings' NOTE
  . <- raw_name <- tidy_name <- xxxx_row_num <- values <- ct <- NULL
  
  # Error out if column key does not contain all needed information
  if(all(c("source", "raw_name", "tidy_name") %in% names(key)) != TRUE)
    stop("Column key must include 'source', 'raw_name' and 'tidy_name' columns")
  
  # Drop any unnecessary column key columns
  key_actual <- key %>% 
    dplyr::select(source, raw_name, tidy_name) %>% 
    dplyr::distinct()
  
  # Read in all files in folder of specified type(s)
  df_list <- ltertools::read(raw_folder = raw_folder, data_format = data_format)
  
  # Collapse data formats into a 1-element vector
  formats <- paste0(data_format, collapse = "|")
  
  # Identify available raw files *that are also present in the column key*
  raw_files <- base::intersect(x = dir(path = raw_folder, pattern = formats),
                               y = unique(key_actual$source))
  
  # Identify any files present but not in column key
  unk_files <- base::setdiff(x = dir(path = raw_folder, pattern = formats),
                             y = unique(key_actual$source))
  
  # If any are found and `quiet` isn't `TRUE`, report on these files
  if(length(unk_files) != 0 & quiet != TRUE){
    message("Following files found in raw path but not in key:")
    print(paste0("'", unk_files, "'", collapse = " & ")) }
  
  # Create an empty list for storing each harmonized raw file (pre-combination)
  file_list <- list()
  
  # Loop across files that *are* in the column key
  for(focal_file in raw_files){
    
    # Prepare the column key
    key_sub <- key_actual %>% 
      # Subset to just this file
      dplyr::filter(source == focal_file) %>% 
      # Drop any instances where the harmonized name is absent
      ## (assuming that raw column is unwanted in harmonized data object)
      dplyr::filter(is.na(tidy_name) != TRUE & nchar(tidy_name) != 0)
    
    # Error out if duplicate tidy names are discovered
    if(nrow(key_sub) != length(unique(key_sub$tidy_name)))
      stop("All 'tidy_name' entries must be unique")
    
    # Grab that file from the list generated by `ltertools::read`
    dat_v1 <- df_list[[focal_file]]
    
    # Identify any columns in the column key but apparently not in the data
    missing_cols <- base::setdiff(x = unique(key_sub$raw_name),
                                  y = names(dat_v1))
    
    # Warn the user if any are found (this is a warning so no `quiet` argument used)
    if(length(missing_cols) != 0){
      warning(message = paste0("Following columns in key NOT found in '", focal_file, "': '", missing_cols, "'", collapse = " & ")) }
    
    # Identify columns in data but not in key
    untidy_cols <- setdiff(x = names(dat_v1), y = unique(key_sub$raw_name))
    
    # Prepare the data for harmonization via column key
    dat_v2 <- dat_v1 %>% 
      # Remove all columns without tidy equivalents
      dplyr::select(-dplyr::all_of(untidy_cols)) %>% 
      # Make all columns characters
      dplyr::mutate(dplyr::across(.cols = dplyr::everything(),
                                  .fns = as.character)) %>% 
      # Add a filename column
      dplyr::mutate(source = focal_file, .before = dplyr::everything())
    
    # Replace original column names with tidy equivalents
    dat_v3 <- supportR::safe_rename(data = dat_v2,
                                    bad_names = key_sub$raw_name,
                                    good_names = key_sub$tidy_name)
    
    # Add to list
    file_list[[focal_file]] <- dat_v3 } # Close harmonization loop
  
  # Unlist the list
  files_df <- purrr::list_rbind(x = file_list)
  
  # Return that
  return(files_df) }

# # Read in key
# key_obj <- read.csv(file = file.path("dev", "key.csv"))
# dplyr::glimpse(key_obj)
# 
# Invoke Function
# test_out <- harm_v2(key = key_obj, raw_folder = file.path("dev", "test-data"),
#                     data_format = "csv", quiet = F)
# 
# # Check structure
# dplyr::glimpse(test_out[1:50])

## ----------------------------- ##
# Speed Tests ----
## ----------------------------- ##

# Get needed input(s)
# Read in key
key_obj <- read.csv(file = file.path("dev", "key.csv"))
dplyr::glimpse(key_obj)

# Speed test new vs. old harmonize functions
# Actually do speed testing
microbenchmark::microbenchmark(
  
  # Old Version
  cran_harmony <- ltertools::harmonize(key = key_obj, raw_folder = file.path("dev", "test-data"),
                                      data_format = "csv", quiet = F),
  
  # Upgraded version
  v2_harmony <- harm_v2(key = key_obj, raw_folder = file.path("dev", "test-data"),
                         data_format = "csv", quiet = F),
  
  # Number of times to test
  times = 50) # Close `microbenchmark`

# March 25, 2025 -- Speed Test Results:
## ver.    min         lq          mean         median       uq          max      neval  cld
## CRAN    14.995852   18.674327   19.76731     19.31185     20.57290    26.03305  50     a 
## v2     7.908361     8.399373    12.18750     12.25346     15.02888    18.68110  50     b

# End ----
