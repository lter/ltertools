#' @title Harmonize Data via a Column Key
#' 
#' @description A "column key" is meant to streamline harmonization of disparate datasets. This key must include three columns containing: (1) the name of each raw data file to be harmonized, (2) the name of all of the columns in each of those files, and (3) the "tidy name" that corresponds to each raw column name. This function accepts that key and the path to a folder containing all raw data files included in the key. Each dataset is then read in and the original column names are replaced with their respective "tidy_name" indicated in the key. Once this has been done to all files, a single dataframe is returned with only columns indicated in the column name. Currently the following file formats are supported for the raw data: CSV, TXT, XLS, and XLSX. This function was built by the following authors: Nicholas Lyon
#' 
#' Note that raw column names without an associated tidy name in the key are removed. We recommend using the `begin_key` function in this package to generate the skeleton of the key to make achieving the required structure simpler. 
#'
#' @param key (dataframe) key object including a "source", "raw_name" and "tidy_name" column. Additional columns are allowed but ignored
#' @param raw_folder (character) folder / folder path containing data files to include in key
#' @param data_format (character) file extensions to identify within the `raw_folder`. Default behavior is to search for all supported file types.
#' @param quiet (logical) whether to suppress certain non-warning messages. Defaults to `TRUE`
#' 
#' @return (dataframe) harmonized dataframe including all columns defined in the "tidy_name" column of the key object
#' 
#' @importFrom magrittr %>% 
#' 
#' @export
#' 
#' @examples
#' \dontrun{
#' # Harmonize a set of raw data with a column key
#' ## Note that the `data_format` argument is not specified which defaults to all supported file types
#' harmonize(key = key_object, raw_folder = file.path("raw_data"), quiet = FALSE)
#' }
#' 
harmonize <- function(key = NULL, raw_folder = NULL, data_format = c("csv", "txt", "xls", "xlsx"), quiet = TRUE){
  # Squelch 'visible bindings' NOTE
  . <- raw_name <- tidy_name <- xxxx_row_num <- values <- NULL

  # Error out if data key does not contain all needed information
  if(all(c("source", "raw_name", "tidy_name") %in% names(key)) != TRUE)
    stop("Data key must include 'source', 'raw_name' and 'tidy_name' columns")
  
  # Drop any unnecessary data key columns
  key_actual <- key %>% 
    dplyr::select(source, raw_name, tidy_name) %>% 
    dplyr::distinct()
  
  # Read in all files in folder of specified type(s)
  df_list <- ltertools::read(raw_folder = raw_folder, data_format = data_format)
  
  # Collapse data formats into a 1-element vector
  formats <- paste0(data_format, collapse = "|")
  
  # Identify available raw files *that are also present in the data key*
  raw_files <- generics::intersect(x = dir(path = raw_folder, pattern = formats),
                                   y = unique(key_actual$source))
  
  # Identify any files present but not in data key
  unk_files <- generics::setdiff(x = dir(path = raw_folder, pattern = formats),
                                 y = unique(key_actual$source))
  
  # If any are found and `quiet` isn't `TRUE`, report on these files
  if(length(unk_files) != 0 & quiet != TRUE){
    message("Following files found in raw path but not in data key:")
    print(paste0("'", unk_files, "'", collapse = " & ")) }
  
  # Create an empty list for storing each harmonized raw file (pre-combination)
  file_list <- list()
  
  # Loop across files that *are* in the data key
  for(focal_file in raw_files){

    # Prepare the data key
    key_sub <- key_actual %>% 
      # Subset to just this file
      dplyr::filter(source == focal_file) %>% 
      # Drop any instances where the harmonized name is absent
      ## (assuming that raw column is unwanted in harmonized data object)
      dplyr::filter(is.na(tidy_name) != TRUE & nchar(tidy_name) != 0)
    
    # Grab that file from the list generated by `ltertools::read`
    dat_v1 <- df_list[[focal_file]]
    
    # Prepare the data for harmonization via data key
    dat_v2 <- dat_v1 %>% 
      # Add a source column and row number column to preserve original rows
      ## (name is bizarre to avoid overwriting extant column name)
      dplyr::mutate(xxxx_row_num = 1:nrow(x = .),
                    source = focal_file) %>% 
      # Make all columns characters
      dplyr::mutate(dplyr::across(.cols = dplyr::everything(),
                                  .fns = as.character)) %>% 
      # Pivot the data into 'ultimate' long format
      tidyr::pivot_longer(cols = -xxxx_row_num:-source,
                          names_to = "raw_name",
                          values_to = "values")
    
    # Identify any columns in the data key but apparently not in the data
    missing_cols <- generics::setdiff(x = unique(key_sub$raw_name),
                                      y = unique(dat_v2$raw_name))
    
    # Warn the user if any are found (this is a warning so no `quiet` argument used)
    if(length(missing_cols) != 0){
      rlang::warn(message = paste0("Removing the following columns in data key NOT found in '", focal_file, "': '", missing_cols, "'", collapse = " & ")) }
    
    # Perform actual harmonization
    dat_v3 <- dat_v2 %>% 
      # Attach the data key to the data
      dplyr::left_join(y = key_sub, by = c("source", "raw_name")) %>% 
      # Drop any columns without a standardized name
      dplyr::filter(is.na(tidy_name) != TRUE & nchar(tidy_name) != 0) %>% 
      # Trash the old column names
      dplyr::select(-raw_name) %>% 
      # Pivot back to original format
      tidyr::pivot_wider(names_from = tidy_name, values_from = values) %>% 
      # Trash row number column created in loop
      dplyr::select(-xxxx_row_num)
    
    # Add to list
    file_list[[focal_file]] <- dat_v3 } # Close harmonization loop
  
  # Unlist the list
  files_df <- purrr::list_rbind(x = file_list)
  
  # Return that
  return(files_df) }
